#!/usr/bin/env python3

import rospy
import math
import smach
import copy

from typing import List
from tf.transformations import quaternion_from_euler
from ObjectInfo import ObjectInfo
from geometry_msgs.msg import Point, Quaternion, PoseStamped
from nav_msgs.msg import GridCells

"""This state optimises the order in which objects are to be
picked up and dropped off to maximise efficiency.
"""
class Optimise(smach.State):
    def __init__(self):
        smach.State.__init__(self, 
                             outcomes=["succeeded"],
                             input_keys=["pickup_info"],
                             output_keys=["pickup_info"])

    def _generate_points_around(self, 
                                centre: PoseStamped, 
                                radius: float,
                                count: int = 10) -> List[PoseStamped]:
        """Generates a list of poses on the circumfrence of a 
        circle with the given dimensions. It makes sure that
        the poses x-axis is pointing towards the centre of the
        circle.
        """
        poses = []

        for i in range(count):
            angle = 2.0 * math.pi * i / count
            x = radius * math.cos(angle)
            y = radius * math.sin(angle)

            pose_stamped = PoseStamped()
            pose_stamped.header.stamp = rospy.Time.now()
            pose_stamped.header.frame_id = centre.header.frame_id

            pose_stamped.pose.position.x = x
            pose_stamped.pose.position.y = y
            pose_stamped.pose.position.z = 0.0

            # make sure the x-axis of the pose is always pointing 
            # towards the centre of the circle
            quaternion = quaternion_from_euler(0.0, 0.0, math.atan2(centre.pose.position.y - y,
                                                                    centre.pose.position.x - x),
                                                                    axes="szyx") 
            pose_stamped.pose.orientation = Quaternion(*quaternion)

            poses.append(pose_stamped)

        return poses

    def get_obstacle_map(self, wait=2.0) -> GridCells:
        """Returns the static obstacle map as generated by
        the map.
        """
        obstacle_map = None
        try:
            obstacle_map = rospy.wait_for_message("/base_path_planner/inflated_static_obstacle_map",
                                                  GridCells,
                                                  timeout=wait)
            rospy.loginfo(f"Obtained obstacle map.")
        except rospy.ROSException as e:
            rospy.logwarn(f"Timeout reached. No message received within {wait} seconds. \
                Error: {e}")

        return obstacle_map

    def _add_pickup_poses(self, ud) -> None:
        obstacle_map = self.get_obstacle_map()
        for object in ud.pickup_info:
            points_around = self._generate_points_around(object.get_position())

    def _generate_pickup_pose(self, target_object:ObjectInfo) -> PoseStamped:
        """Generates pickup poses for each of the objects. Checks
        for collisions with other obstacles and other objects.
        """
        pickup_pose = PoseStamped()
        pickup_pose.header.frame_id = "map"
        pickup_pose.header.stamp = rospy.Time.now()
        pickup_pose.pose.position = target_object.get_position().point
        pickup_pose.pose.position.x -= 0.21 * 3
        pickup_pose.pose.orientation = Quaternion(x=0.0, y=0.0, z=0.0, w=1.0) 

        return pickup_pose

    # TODO: use this topic for grid cells /base_path_planner/inflated_static_obstacle_map
    # TODO: use https://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection

    def execute(self, ud):
        ud.pickup_info[0].add_pickup_location(self._generate_pickup_pose(
            copy.deepcopy(ud.pickup_info[0])
        ))
        ud.pickup_info[1].add_pickup_location(self._generate_pickup_pose(
            copy.deepcopy(ud.pickup_info[1])
        ))
        ud.pickup_info[2].add_pickup_location(self._generate_pickup_pose(
            copy.deepcopy(ud.pickup_info[2])
        ))
        return "succeeded"