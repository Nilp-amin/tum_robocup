#!/usr/bin/env python3

import rospy
import math
import smach
import numpy as np
from itertools import permutations
import copy

from typing import List
from tf.transformations import quaternion_from_euler
from ObjectInfo import ObjectInfo
from geometry_msgs.msg import Point, Quaternion, PoseStamped, PointStamped, PoseArray
from nav_msgs.msg import GridCells

"""This state optimises the order in which objects are to be
picked up and dropped off to maximise efficiency.
"""
class Optimise(smach.State):
    ROBOT_RADIUS = 0.21
    ROBOT_RADIUS_BUFFER = 0.15
    DIST_FROM_OBJECT = ROBOT_RADIUS * 3
    def __init__(self):
        smach.State.__init__(self, outcomes=["succeeded", "failed"],
                             input_keys=["pickup_info"],
                             output_keys=["pickup_info"])

        self._debug_pub = rospy.Publisher("/rviz_visual_tools", PoseArray, queue_size=10)

    def _generate_pose_around(self, 
                                centre: PointStamped, 
                                radius: float,
                                count: int = 10) -> List[PoseStamped]:
        """Generates a list of poses on the circumfrence of a 
        circle with the given dimensions. It makes sure that
        the poses x-axis is pointing towards the centre of the
        circle.
        """
        poses = []
        for i in range(count):
            angle = 2.0 * math.pi * i / count
            x = radius * math.cos(angle) + centre.point.x
            y = radius * math.sin(angle) + centre.point.y

            pose_stamped = PoseStamped()
            pose_stamped.header.stamp = rospy.Time.now()
            pose_stamped.header.frame_id = centre.header.frame_id

            pose_stamped.pose.position.x = x
            pose_stamped.pose.position.y = y
            pose_stamped.pose.position.z = 0.0

            # make sure the x-axis of the pose is always pointing 
            # towards the centre of the circle
            quaternion = quaternion_from_euler(0.0, 0.0, math.atan2(centre.point.y - y,
                                                                    centre.point.x - x)) 
            pose_stamped.pose.orientation = Quaternion(*quaternion)

            poses.append(pose_stamped)

        return poses

    
    def _cell_intersects(self, r: float, cx: float, cy: float, rw: float, rh: float) -> bool:
        """ Checks if there is an intersection between a rectangle and a circle.
        The position of the circle is relative to the rectangle. The rectangle
        is also assumed to be axis-aligned.
        Algo: https://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection 
        """
        if cx > (rw / 2 + r): return False
        if cy > (rh / 2 + r): return False

        if cx <= rw / 2: return True
        if cy <= rh / 2: return True

        corner_dist_squared = (cx - rw / 2)**2 + (cy - rh / 2)**2

        return corner_dist_squared <= r**2

    def _object_intersects(self, r: float, ox: float, oy: float) -> bool:
        """Checks if there is an intersection between an
        object and a circle. The position of the object is 
        relative to the circle.
        """
        object_distance_squared = ox**2 + oy**2
        return object_distance_squared <= r**2

    def _collision(self, 
                    pose: PoseStamped, 
                    obstacle_map: GridCells, 
                    other_objects: List[ObjectInfo]) -> bool:
        """Checks in a circular region centred at the given pose
        for collision. The circular region is greater than the radius
        of the robot.
        """
        # check for collisions with the obstacle map itself
        for cell in obstacle_map.cells:
            if self._cell_intersects(r=Optimise.ROBOT_RADIUS + Optimise.ROBOT_RADIUS_BUFFER,
                                cx=abs(pose.pose.position.x - cell.x),
                                cy=abs(pose.pose.position.y - cell.y),
                                rw=obstacle_map.cell_width,
                                rh=obstacle_map.cell_height):
                return True 

        # check for collisions with other pickup objects which are not
        # represented into the static obstacle map
        for object_info in other_objects:
            object_position = object_info.get_position().point
            if self._object_intersects(r=Optimise.ROBOT_RADIUS + Optimise.ROBOT_RADIUS_BUFFER,
                                       ox=abs(object_position.x - pose.pose.position.x),
                                       oy=abs(object_position.y - pose.pose.position.y)):
                return True 

        return False 

    def get_obstacle_map(self, wait=2.0) -> GridCells:
        """Returns the static obstacle map as generated by
        the map.
        """
        obstacle_map = None
        try:
            obstacle_map = rospy.wait_for_message("/base_path_planner/inflated_static_obstacle_map",
                                                  GridCells,
                                                  timeout=wait)
            rospy.loginfo(f"Obtained obstacle map.")
        except rospy.ROSException as e:
            rospy.logwarn(f"Timeout reached. No message received within {wait} seconds. \
                Error: {e}")

        return obstacle_map

    def _add_pickup_poses(self, ud) -> None:
        """Adds valid pickup locations for each of the 
        detected objects. A valid pickup location is defined
        by one where no collisions occur when the robot is at
        the given pickup location.
        """
        pose_array_msg = PoseArray()
        pose_array_msg.header.frame_id = "map"
        pose_array_msg.header.stamp = rospy.Time.now()
        obstacle_map = self.get_obstacle_map()
        for i, object in enumerate(ud.pickup_info):
            pose_around = self._generate_pose_around(centre=object.get_position(),
                                                     radius=Optimise.DIST_FROM_OBJECT)
            for pose in pose_around:
                # check if there are any collisions between the robot
                # at pose and environment
                if not self._collision(pose, obstacle_map, ud.pickup_info[i + 1:]):
                    object.add_pickup_location(pose)
                    pose_array_msg.poses.append(pose.pose)

        self._debug_pub.publish(pose_array_msg)

    def execute(self, ud):
        # ud.target_object.add_pickup_location(ud.target_object.get_position())
        rospy.loginfo("Start of Optimisation")
                ## 3 instances of class object_info
        info_object_A = copy.deepcopy(ud.pickup_info[0])#.get_position()
        info_object_B = copy.deepcopy(ud.pickup_info[1])#.get_position()
        info_object_C = copy.deepcopy(ud.pickup_info[2])#.get_position()
        
                ## get pose of the objects and label and save in dictionary format
                ## pose is np.array([x,y]) and label is string 
        # get pointstamp_msg for pose of the object (x,y)
        point_stamped_msgA = info_object_A.get_position()
        point_stamped_msgB = info_object_B.get_position()
        point_stamped_msgC = info_object_C.get_position()

        # get the class label [["Cup", "Bottle", "Pringles"]]
        class_objectA = info_object_A.get_class()
        class_objectB = info_object_B.get_class()
        class_objectC = info_object_C.get_class()


        A = np.array([point_stamped_msgA.point.x , point_stamped_msgA.point.y])
        B = np.array([point_stamped_msgB.point.x , point_stamped_msgB.point.y])
        C = np.array([point_stamped_msgC.point.x , point_stamped_msgC.point.y])
        
        dict_objects = {
            'object_A' : A,
            'object_B' : B,
            'object_C' : C 
        }
 
        rospy.loginfo(dict_objects)
        all_combinations_dic = list(permutations(dict_objects))
        # print(len(all_combinations_dic))
        # print(all_combinations_dic[5]) 

        ## get drop of location 
        pose_stamped_msgA = info_object_A.get_dropoff_point()
        pose_stamped_msgB = info_object_B.get_dropoff_point()
        pose_stamped_msgC = info_object_C.get_dropoff_point()

        place_drop_objectA = (pose_stamped_msgA.pose.position.x , pose_stamped_msgA.pose.position.y)
        place_drop_objectB = (pose_stamped_msgB.pose.position.x , pose_stamped_msgB.pose.position.y)
        place_drop_objectC = (pose_stamped_msgC.pose.position.x , pose_stamped_msgC.pose.position.y)

        totall_distance = 0 #### HIER IN LOOP DA ICH ES 0ELN MUSS
        list_totall_distance = []
        list_totall_path = []
        ## start position -> Robot in position search_one or search_two
        if ud.nav_goal_index == 1:
             waypoint_two = rospy.get_param("/way_points/search_two")
        #      start = (waypoint_one['search_one']['x'] , waypoint_one['search_one']['y'] )
             start = (waypoint_two['x'] , waypoint_two['y'] )
             
        elif ud.nav_goal_index == 2:
             waypoint_one = rospy.get_param("/way_points/search_one")
        #      start = (waypoint_two['search_two']['x'] , waypoint_two['search_one']['y'] )
             start = (waypoint_one['x'] , waypoint_one['y'] )
             


        for j in range (0,len(all_combinations_dic)):
                sequence_order = all_combinations_dic[j]
                print(j)
                for i in range(0,len(sequence_order)): # for A , B, C 
                # print(totall_distance)
                # print(i)
                        if i == 0:
                            if  sequence_order[i] == 'object_A':
                                print('First go to object_A, pick up and bring to place_drop_objectA')
                                start_distance = np.linalg.norm(A-start)
                                distance = np.linalg.norm(place_drop_objectA - A)
                                totall_distance += distance + start_distance
                            if  sequence_order[i] == 'object_B':
                                print('First go to object_B, pick up and bring to place_drop_objectB')
                                start_distance = np.linalg.norm(B-start)
                                distance = np.linalg.norm(place_drop_objectB - B)
                                totall_distance += distance + start_distance
                            if  sequence_order[i] == 'object_C':
                                print('First go to object_C and , pick up bring to place_drop_objectC')
                                start_distance = np.linalg.norm(C-start)
                                distance = np.linalg.norm(place_drop_objectC - C)
                                totall_distance += distance + start_distance
                        else:
                            if  sequence_order[i] == 'object_A':
                                print('Go to object_A, pick up and bring to place_drop_objectA')
                                if sequence_order[i-1] == 'object_B':
                                    distance_back_object = np.linalg.norm(A-place_drop_objectB)
                                if sequence_order[i-1] == 'object_C':
                                    distance_back_object = np.linalg.norm(A-place_drop_objectC)
                                distance = np.linalg.norm(place_drop_objectA - A)
                                totall_distance += distance + distance_back_object
                            if  sequence_order[i] == 'object_B':
                                print('Go to object_B and bring to place_drop_objectB')
                                if sequence_order[i-1] == 'object_A':
                                    distance_back_object = np.linalg.norm(B-place_drop_objectA)
                                if sequence_order[i-1] == 'object_C':
                                    distance_back_object = np.linalg.norm(B-place_drop_objectC)
                                distance = np.linalg.norm(place_drop_objectB - B)
                                totall_distance += distance + distance_back_object
                            if  sequence_order[i] == 'object_C':
                                print('Go to object_C and bring to place_drop_objectC')
                                if sequence_order[i-1] == 'object_A':
                                    distance_back_object = np.linalg.norm(C-place_drop_objectA)
                                if sequence_order[i-1] == 'object_B':
                                    distance_back_object = np.linalg.norm(C-place_drop_objectB)
                                distance = np.linalg.norm(place_drop_objectC - C)
                                totall_distance += distance + distance_back_object
                print('The totall distance for the Path', sequence_order, 'is', totall_distance)

                list_totall_distance.insert(j,totall_distance)
                list_totall_path.insert(j,sequence_order)
                totall_distance = 0

        
        # print(min_distance.index(min(min_distance)))
        min_distance = min(list_totall_distance)
        min_path = list_totall_path[list_totall_distance.index(min(list_totall_distance))]
        print('The shortest path is', min_path, 'and has a distance of', min_distance)

        #            ## 3 instances of class object_info
        # info_object_A = ud.pickup_info[0]#.get_position()
        # info_object_B = ud.pickup_info[1]#.get_position()
        # info_object_C = ud.pickup_info[2]#.get_position()
        
        for l in range(0,len(min_path)):
            if min_path[l] == 'object_A':
                ud.pickup_info[l] = info_object_A
            if min_path[l] == 'object_B':
                ud.pickup_info[l] = info_object_B
            if min_path[l] == 'object_C':
                ud.pickup_info[l] = info_object_C

        self._add_pickup_poses(ud)

        return "succeeded"
